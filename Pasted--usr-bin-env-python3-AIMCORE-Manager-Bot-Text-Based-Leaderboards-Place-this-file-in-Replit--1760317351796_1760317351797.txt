#!/usr/bin/env python3
"""
AIMCORE Manager Bot (Text-Based Leaderboards)

Place this file in Replit as `aimcore_manager_bot.py` and edit the variables below:
 - BOT_TOKEN: your token from @BotFather (string)
 - ADMIN_IDS: list of Telegram user IDs allowed to run admin-only commands (integers)

Features:
 - /register <slot> <team name>  (admin only) ‚Äî register a team and assign a numeric slot
 - /teams ‚Äî list all registered teams
 - /myslot <team name> ‚Äî returns slot for a team
 - /results <multi-line or single-line> ‚Äî submit results for a slot across 3 lobbies
 - /leaderboard [today|lobby1|lobby2|lobby3|weekly] ‚Äî show leaderboard
 - Data persistence via JSON files: teams.json and results.json
"""

import json
import os
from datetime import date, datetime
import re
from collections import defaultdict

from telegram import Update, ParseMode
from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes

# ------------------ CONFIG ------------------
BOT_TOKEN = "PASTE_YOUR_TOKEN_HERE"
ADMIN_IDS = [0]  # Replace 0 with your Telegram numeric ID

TEAMS_FILE = "teams.json"
RESULTS_FILE = "results.json"

# ------------------ UTILITIES ------------------

def load_json(path, default):
    if os.path.exists(path):
        try:
            with open(path, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception:
            return default
    return default

def save_json(path, data):
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2, ensure_ascii=False)

teams = load_json(TEAMS_FILE, {})
results = load_json(RESULTS_FILE, {})

# Placement points per your spec
def placement_points(place):
    if place == 1: return 30
    if place == 2: return 25
    if place == 3: return 20
    if place == 4: return 18
    if 5 <= place <= 9: return 15
    if 10 <= place <= 15: return 10
    if 16 <= place <= 20: return 5
    return 0

def ensure_date_entry(datestr):
    if datestr not in results:
        results[datestr] = {}
        save_json(RESULTS_FILE, results)

# ------------------ PARSING HELPERS ------------------

def find_slot_in_text(text):
    m = re.search(r'\b[Ss]?(\d{1,3})\b', text)
    if m:
        return str(int(m.group(1)))
    return None

def parse_results_text(text):
    data = {}
    lines = [ln.strip() for ln in text.splitlines() if ln.strip()]
    full = " ".join(lines)
    for lobby_num in [1,2,3]:
        pat = re.compile(r'(?:Lobby[\s\-]*?%d|%d(?:st|nd|rd|th)?\s+lobby).*?P(?:lace)?\s*[:\-]?\s*(\d{1,2}).*?K(?:ills)?\s*[:\-]?\s*(\d{1,3})' % (lobby_num, lobby_num), re.IGNORECASE)
        m = pat.search(full)
        if m:
            data[f"lobby{lobby_num}"] = {"place": int(m.group(1)), "kills": int(m.group(2))}
    if not data:
        tokens = re.findall(r'P\s*(\d{1,2})\s*K\s*(\d{1,3})', full, re.IGNORECASE)
        if len(tokens) >= 3:
            for i in range(3):
                p, k = tokens[i]
                data[f"lobby{i+1}"] = {"place": int(p), "kills": int(k)}
    if all(f"lobby{i}" in data for i in (1,2,3)):
        return data
    return None

# ------------------ SCORING ------------------

def calculate_team_daily_points(lobby_data):
    pp_total = 0
    kills_total = 0
    details = {}
    for i in (1,2,3):
        lb = lobby_data.get(f"lobby{i}", {"place":0,"kills":0})
        p = int(lb.get("place",0))
        k = int(lb.get("kills",0))
        pts = placement_points(p) + k
        details[f"lobby{i}"] = {"place": p, "kills": k, "placement_pts": placement_points(p), "total_pts": pts}
        pp_total += placement_points(p)
        kills_total += k
    combined = pp_total + kills_total
    return {"placement_points": pp_total, "kills": kills_total, "combined": combined, "details": details}

def aggregate_daily_leaderboard(datestr):
    ensure_date_entry(datestr)
    day = results.get(datestr, {})
    table = []
    for slot, data in day.items():
        team_name = teams.get(slot, f"Slot {slot}")
        calc = calculate_team_daily_points(data)
        table.append((team_name, slot, calc["combined"], calc["kills"], calc["placement_points"]))
    table.sort(key=lambda x: x[2], reverse=True)
    return table

def aggregate_lobby_leaderboard(datestr, lobby_num):
    ensure_date_entry(datestr)
    day = results.get(datestr, {})
    table = []
    for slot, data in day.items():
        team_name = teams.get(slot, f"Slot {slot}")
        lb = data.get(f"lobby{lobby_num}", {"place":0,"kills":0})
        place = int(lb.get("place",0))
        kills = int(lb.get("kills",0))
        pts = placement_points(place) + kills
        table.append((team_name, slot, pts, kills, place))
    table.sort(key=lambda x: x[2], reverse=True)
    return table

def aggregate_weekly_leaderboard(week_year_str):
    week_totals = defaultdict(lambda: {"team": "", "combined": 0, "kills": 0, "placement": 0})
    for dstr, daydata in results.items():
        try:
            dt = datetime.fromisoformat(dstr).date()
        except Exception:
            continue
        wk = dt.isocalendar()
        wk_str = f"{wk[0]}-W{wk[1]}"
        if wk_str != week_year_str:
            continue
        for slot, data in daydata.items():
            team_name = teams.get(slot, f"Slot {slot}")
            calc = calculate_team_daily_points(data)
            entry = week_totals[slot]
            entry["team"] = team_name
            entry["combined"] += calc["combined"]
            entry["kills"] += calc["kills"]
            entry["placement"] += calc["placement_points"]
    rows = []
    for slot, v in week_totals.items():
        rows.append((v["team"], slot, v["combined"], v["kills"], v["placement"]))
    rows.sort(key=lambda x: x[2], reverse=True)
    return rows

# ------------------ TELEGRAM HANDLERS ------------------

def is_admin(user_id):
    return int(user_id) in ADMIN_IDS

async def start_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("üî• AIMCORE Manager Bot Online!\nUse /help to see available commands.")

async def help_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (
        "üìã AIMCORE Bot Commands (Admin-only commands marked with üîí):\n\n"
        "üîí /register <slot> <team name>\n"
        "/teams ‚Äî list registered teams\n"
        "/myslot <team name> ‚Äî find slot\n"
        "/results <text> ‚Äî submit results for 3 lobbies\n"
        "/leaderboard [today|lobby1|lobby2|lobby3|weekly]\n"
        "üîí /resetday <YYYY-MM-DD>\n"
        "üîí /resetweek <YYYY-Www>\n"
    )
    await update.message.reply_text(text)

async def register_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not is_admin(user.id):
        await update.message.reply_text("‚ùå Admins only.")
        return
    args = context.args
    if not args:
        await update.message.reply_text("Usage: /register <slot> <team name>")
        return
    slot = None
    team_name = None
    if args[-1].isdigit():
        slot = str(int(args[-1]))
        team_name = " ".join(args[:-1])
    elif args[0].isdigit():
        slot = str(int(args[0]))
        team_name = " ".join(args[1:])
    else:
        if len(args) >= 2 and args[-2].lower() == "slot" and args[-1].isdigit():
            slot = str(int(args[-1]))
            team_name = " ".join(args[:-2])
    if not slot or not team_name:
        await update.message.reply_text("Could not parse. Use: /register <slot> <team name>")
        return
    teams[slot] = team_name.strip()
    save_json(TEAMS_FILE, teams)
    await update.message.reply_text(f"‚úÖ Registered team *{team_name}* with Slot *{slot}*.", parse_mode=ParseMode.MARKDOWN)

async def teams_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not teams:
        await update.message.reply_text("No teams registered yet.")
        return
    lines = ["üéüÔ∏è AIMCORE TEAM SLOTS"]
    for slot in sorted(teams, key=lambda